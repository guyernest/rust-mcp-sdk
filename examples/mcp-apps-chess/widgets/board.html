<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Board</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            max-width: 600px;
            width: 100%;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.5rem;
        }

        .status {
            text-align: center;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            background: #16213e;
        }

        .status.white-turn { border-left: 4px solid #f0d9b5; }
        .status.black-turn { border-left: 4px solid #b58863; }
        .status.error { background: #4a1515; border-left: 4px solid #ff6b6b; }

        .board-container {
            display: flex;
            justify-content: center;
            margin-bottom: 15px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            border: 3px solid #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .square {
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .square.light { background: #f0d9b5; }
        .square.dark { background: #b58863; }

        .square.selected {
            background: #7b61ff !important;
            box-shadow: inset 0 0 0 3px #fff;
        }

        .square.valid-move::after {
            content: '';
            width: 12px;
            height: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
        }

        .square.valid-capture {
            box-shadow: inset 0 0 0 4px rgba(255, 0, 0, 0.4);
        }

        .square:hover:not(.selected) {
            filter: brightness(1.1);
        }

        .piece {
            user-select: none;
            text-shadow: 0 1px 2px rgba(0,0,0,0.5);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            background: #4a90d9;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
        }

        button:hover {
            background: #3a7bc8;
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .history {
            margin-top: 15px;
            padding: 10px;
            background: #16213e;
            border-radius: 8px;
            max-height: 100px;
            overflow-y: auto;
        }

        .history h3 {
            font-size: 0.9rem;
            margin-bottom: 8px;
            color: #888;
        }

        .history-moves {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            font-family: monospace;
            font-size: 0.85rem;
        }

        .history-moves span {
            background: #0f3460;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            display: none;
        }

        .loading.visible { display: block; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess</h1>

        <div id="status" class="status white-turn">
            White to move
        </div>

        <div class="board-container">
            <div id="board" class="board"></div>
        </div>

        <div class="controls">
            <button id="newGameBtn">New Game</button>
            <button id="undoBtn" disabled>Undo</button>
        </div>

        <div class="history">
            <h3>Move History</h3>
            <div id="history" class="history-moves"></div>
        </div>
    </div>

    <div id="loading" class="loading">
        Processing...
    </div>

    <script>
        // Chess piece Unicode characters
        const PIECES = {
            white: { king: '\u2654', queen: '\u2655', rook: '\u2656', bishop: '\u2657', knight: '\u2658', pawn: '\u2659' },
            black: { king: '\u265A', queen: '\u265B', rook: '\u265C', bishop: '\u265D', knight: '\u265E', pawn: '\u265F' }
        };

        // Game state
        let gameState = null;
        let selectedSquare = null;
        let validMoves = [];

        // DOM elements
        const boardEl = document.getElementById('board');
        const statusEl = document.getElementById('status');
        const historyEl = document.getElementById('history');
        const loadingEl = document.getElementById('loading');
        const newGameBtn = document.getElementById('newGameBtn');
        const undoBtn = document.getElementById('undoBtn');

        // Initialize board UI
        function initBoard() {
            boardEl.innerHTML = '';
            for (let rank = 7; rank >= 0; rank--) {
                for (let file = 0; file < 8; file++) {
                    const square = document.createElement('div');
                    const isLight = (rank + file) % 2 === 1;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.rank = rank;
                    square.dataset.file = file;
                    square.addEventListener('click', handleSquareClick);
                    boardEl.appendChild(square);
                }
            }
        }

        // Render the current game state
        function render() {
            if (!gameState) return;

            // Update board
            const squares = boardEl.querySelectorAll('.square');
            squares.forEach(square => {
                const rank = parseInt(square.dataset.rank);
                const file = parseInt(square.dataset.file);
                const piece = gameState.board[rank][file];

                // Clear classes
                square.classList.remove('selected', 'valid-move', 'valid-capture');

                // Add piece
                if (piece) {
                    const unicode = PIECES[piece.color][piece.type];
                    square.innerHTML = `<span class="piece">${unicode}</span>`;
                } else {
                    square.innerHTML = '';
                }

                // Highlight selected square
                if (selectedSquare && selectedSquare.rank === rank && selectedSquare.file === file) {
                    square.classList.add('selected');
                }

                // Show valid moves
                const pos = posToAlgebraic(file, rank);
                if (validMoves.includes(pos)) {
                    if (piece) {
                        square.classList.add('valid-capture');
                    } else {
                        square.classList.add('valid-move');
                    }
                }
            });

            // Update status
            const turnText = gameState.turn === 'white' ? 'White' : 'Black';
            let statusText = `${turnText} to move`;

            if (gameState.status === 'check') {
                statusText = `${turnText} is in check!`;
            } else if (gameState.status === 'checkmate') {
                statusText = `Checkmate! ${gameState.turn === 'white' ? 'Black' : 'White'} wins!`;
            } else if (gameState.status === 'stalemate') {
                statusText = 'Stalemate! Game is a draw.';
            }

            statusEl.textContent = statusText;
            statusEl.className = `status ${gameState.turn}-turn`;

            // Update history
            historyEl.innerHTML = gameState.history
                .map((move, i) => `<span>${Math.floor(i/2) + 1}${i % 2 === 0 ? '.' : '...'} ${move}</span>`)
                .join('');

            // Update undo button
            undoBtn.disabled = gameState.history.length === 0;
        }

        // Convert file/rank to algebraic notation
        function posToAlgebraic(file, rank) {
            return String.fromCharCode(97 + file) + (rank + 1);
        }

        // Handle square click
        async function handleSquareClick(e) {
            const square = e.currentTarget;
            const rank = parseInt(square.dataset.rank);
            const file = parseInt(square.dataset.file);
            const piece = gameState?.board[rank][file];
            const clickedPos = posToAlgebraic(file, rank);

            // If a piece is selected and clicking a valid move
            if (selectedSquare && validMoves.includes(clickedPos)) {
                const fromPos = posToAlgebraic(selectedSquare.file, selectedSquare.rank);
                await makeMove(fromPos + clickedPos);
                return;
            }

            // If clicking own piece, select it
            if (piece && piece.color === gameState.turn) {
                selectedSquare = { file, rank };
                await getValidMoves(clickedPos);
            } else {
                selectedSquare = null;
                validMoves = [];
            }

            render();
        }

        // Call MCP tool
        async function callTool(name, args) {
            showLoading(true);
            try {
                if (window.mcpBridge?.callTool) {
                    return await window.mcpBridge.callTool(name, args);
                }
                throw new Error('MCP bridge not available');
            } catch (error) {
                showError(error.message);
                throw error;
            } finally {
                showLoading(false);
            }
        }

        // Start new game
        async function newGame() {
            try {
                const result = await callTool('chess_new_game', {});
                gameState = result;
                selectedSquare = null;
                validMoves = [];
                render();
                saveState();
            } catch (error) {
                console.error('Failed to start new game:', error);
            }
        }

        // Make a move
        async function makeMove(move) {
            try {
                const result = await callTool('chess_move', {
                    state: gameState,
                    move: move
                });

                if (result.success) {
                    gameState = result.state;
                    selectedSquare = null;
                    validMoves = [];
                    render();
                    saveState();
                } else {
                    showError(result.message || 'Invalid move');
                }
            } catch (error) {
                console.error('Failed to make move:', error);
            }
        }

        // Get valid moves for a position
        async function getValidMoves(position) {
            try {
                const result = await callTool('chess_valid_moves', {
                    state: gameState,
                    position: position
                });
                validMoves = result.moves || [];
            } catch (error) {
                console.error('Failed to get valid moves:', error);
                validMoves = [];
            }
        }

        // Show loading indicator
        function showLoading(visible) {
            loadingEl.classList.toggle('visible', visible);
        }

        // Show error message
        function showError(message) {
            statusEl.textContent = message;
            statusEl.className = 'status error';
            setTimeout(() => render(), 2000);
        }

        // Save state to widget state (for ChatGPT persistence)
        function saveState() {
            if (window.mcpBridge?.setState) {
                window.mcpBridge.setState({ gameState });
            }
        }

        // Load state from widget state
        function loadState() {
            if (window.mcpBridge?.getState) {
                const state = window.mcpBridge.getState();
                if (state?.gameState) {
                    gameState = state.gameState;
                    return true;
                }
            }
            return false;
        }

        // Initialize
        async function init() {
            // Apply theme from environment (ChatGPT)
            const theme = window.mcpBridge?.theme ?? 'dark';
            document.body.classList.add(`theme-${theme}`);
            if (theme === 'light') {
                document.body.style.background = '#f5f5f5';
                document.body.style.color = '#333';
            }

            // Get locale for future localization support
            const locale = window.mcpBridge?.locale ?? 'en-US';
            document.documentElement.lang = locale.split('-')[0];

            initBoard();

            // Try to restore state
            if (!loadState()) {
                // Start new game if no saved state
                await newGame();
            } else {
                render();
            }

            // Report intrinsic height for proper sizing in ChatGPT
            setTimeout(() => {
                window.mcpBridge?.notifyIntrinsicHeight?.(document.body.scrollHeight);
            }, 100);

            // Button handlers
            newGameBtn.addEventListener('click', newGame);
            undoBtn.addEventListener('click', () => {
                // Simplified undo - just remove last move
                // In a real implementation, you'd need to track full history
                showError('Undo not implemented yet');
            });

            // Listen for state updates (ChatGPT)
            window.addEventListener('widgetStateUpdate', (e) => {
                if (e.detail?.gameState) {
                    gameState = e.detail.gameState;
                    render();
                }
            });

            // Listen for OpenAI globals updates (theme changes, etc.)
            window.addEventListener('openai:set_globals', (e) => {
                const globals = e.detail?.globals;
                if (globals?.theme) {
                    document.body.classList.remove('theme-light', 'theme-dark');
                    document.body.classList.add(`theme-${globals.theme}`);
                    if (globals.theme === 'light') {
                        document.body.style.background = '#f5f5f5';
                        document.body.style.color = '#333';
                    } else {
                        document.body.style.background = '#1a1a2e';
                        document.body.style.color = '#eee';
                    }
                }
            });
        }

        // Start when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
