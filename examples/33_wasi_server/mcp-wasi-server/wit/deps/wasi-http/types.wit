package wasi:http/types@0.2.0;

interface types {
    use wasi:io/streams@0.2.0.{input-stream, output-stream};
    use wasi:io/poll@0.2.0.{pollable};
    use wasi:clocks/wall-clock@0.2.0.{datetime};

    type duration = u64;

    record fields {
        // ... content of fields
    }

    resource incoming-request {
        method: func() -> method;
        path-with-query: func() -> string;
        scheme: func() -> option<scheme>;
        authority: func() -> option<string>;
        headers: func() -> fields;
        consume: func() -> result<input-stream>;
    }

    resource outgoing-request {
        constructor(headers: fields);
        body: func() -> result<output-stream>;
        method: func() -> method;
        path-with-query: func() -> string;
        scheme: func() -> option<scheme>;
        authority: func() -> option<string>;
        headers: func() -> fields;
    }

    resource request-options {
        constructor();
        connect-timeout: func() -> option<duration>;
        set-connect-timeout: func(duration: option<duration>) -> result;
        first-byte-timeout: func() -> option<duration>;
        set-first-byte-timeout: func(duration: option<duration>) -> result;
        between-bytes-timeout: func() -> option<duration>;
        set-between-bytes-timeout: func(duration: option<duration>) -> result;
    }

    resource response-outparam {
        set: static func(param: response-outparam, response: result<outgoing-response, error-code>);
    }

    resource incoming-response {
        status: func() -> u16;
        headers: func() -> fields;
        consume: func() -> result<input-stream>;
    }

    resource incoming-body {
        stream: func() -> result<input-stream>;
        finish: static func(this: incoming-body) -> future-trailers;
    }

    resource future-trailers {
        subscribe: func() -> pollable;
        get: func() -> result<option<fields>>;
    }

    resource outgoing-response {
        constructor(headers: fields);
        status-code: func() -> u16;
        set-status-code: func(status-code: u16) -> result;
        headers: func() -> fields;
        body: func() -> result<output-stream>;
    }

    resource future-incoming-response {
        subscribe: func() -> pollable;
        get: func() -> result<result<incoming-response, error-code>>;
    }

    variant method {
        get, head, post, put, delete, connect, options, trace, patch, other(string)
    }

    variant scheme {
        http, https, other(string)
    }

    variant error-code {
        dns-timeout,
        dns-error(string),
        destination-not-found,
        destination-unavailable,
        destination-ip-prohibited,
        destination-ip-unroutable,
        connection-refused,
        connection-terminated,
        connection-timeout,
        connection-read-timeout,
        connection-write-timeout,
        connection-limit-reached,
        tls-protocol-error,
        tls-certificate-error,
        tls-alert-received(string),
        http-request-denied,
        http-request-length-required,
        http-request-body-size(option<u64>),
        http-request-method-invalid,
        http-request-uri-invalid,
        http-request-uri-too-long,
        http-request-header-section-size(option<u32>),
        http-request-header-size(option<u32>),
        http-request-trailer-section-size(option<u32>),
        http-request-trailer-size(option<u32>),
        http-response-incomplete,
        http-response-header-section-size(option<u32>),
        http-response-header-size(option<u32>),
        http-response-body-size(option<u64>),
        http-response-trailer-section-size(option<u32>),
        http-response-trailer-size(option<u32>),
        http-response-transfer-coding(option<string>),
        http-response-content-coding(option<string>),
        http-response-timeout,
        http-upgrade-failed,
        http-protocol-error,
        loop-detected,
        configuration-error,
        internal-error(option<string>),
    }
}