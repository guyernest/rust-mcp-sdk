// GENERATED BY cargo-pmcp - DO NOT EDIT MANUALLY
// Regenerate with: cargo pmcp deploy init --target cloudflare-workers --regenerate
//
// This adapter imports your WASM-compatible core MCP server and wraps it for Cloudflare Workers.
// Your server logic stays in the core crate - this is just deployment scaffolding.
//
// Architecture:
// - Core package: Business logic (WASM-compatible)
// - This adapter: Cloudflare Workers entrypoint

use pmcp-fuzz::build_server;
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    // Set panic hook for better error messages
    console_error_panic_hook::set_once();

    // Log the request
    console_log!("Received: {} {}", req.method(), req.path());

    // Handle CORS preflight
    if req.method() == Method::Options {
        return cors_preflight();
    }

    // Handle GET requests with server info
    if req.method() == Method::Get {
        return server_info();
    }

    // Only handle POST requests for MCP protocol
    if req.method() != Method::Post {
        return Response::error("Only GET and POST methods are supported", 405);
    }

    // Build your WASM-compatible core server
    let server = match build_server() {
        Ok(s) => s,
        Err(e) => {
            console_error!("Failed to build server: {}", e);
            return Response::error(&format!("Server initialization failed: {}", e), 500);
        }
    };

    // Get request body
    let body = match req.text().await {
        Ok(text) => text,
        Err(e) => {
            console_error!("Failed to read body: {}", e);
            return Response::error("Failed to read request body", 400);
        }
    };

    // TODO: Use pmcp::adapters::cloudflare::serve() when available
    // For now, basic JSON-RPC handling
    let response_json = match handle_mcp_request(&server, &body).await {
        Ok(json) => json,
        Err(e) => {
            console_error!("Error handling request: {}", e);
            return Response::error(&format!("Error: {}", e), 500);
        }
    };

    // Return response with CORS headers
    let mut headers = Headers::new();
    headers.set("Content-Type", "application/json")?;
    headers.set("Access-Control-Allow-Origin", "*")?;

    Ok(Response::ok(response_json)?.with_headers(headers))
}

fn cors_preflight() -> Result<Response> {
    let mut headers = Headers::new();
    headers.set("Access-Control-Allow-Origin", "*")?;
    headers.set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")?;
    headers.set("Access-Control-Allow-Headers", "Content-Type")?;
    Ok(Response::empty()?.with_headers(headers))
}

fn server_info() -> Result<Response> {
    let info = serde_json::json!({
        "name": "mcp-server",
        "version": "1.0.0",
        "protocol_version": "2024-11-05",
        "description": "MCP server running on Cloudflare Workers",
        "runtime": "cloudflare-workers",
        "capabilities": {
            "tools": true,
            "resources": false,
            "prompts": false
        }
    });

    let mut headers = Headers::new();
    headers.set("Content-Type", "application/json")?;
    headers.set("Access-Control-Allow-Origin", "*")?;

    Ok(Response::ok(serde_json::to_string_pretty(&info)?)?.with_headers(headers))
}

async fn handle_mcp_request(
    server: &pmcp::Server,
    body: &str,
) -> Result<String> {
    // TODO: This is a placeholder - use pmcp::adapters::cloudflare when available
    // For now, return a simple response indicating the server is set up
    Ok(serde_json::json!({
        "jsonrpc": "2.0",
        "id": "1",
        "result": {
            "message": "Cloudflare Workers adapter initialized",
            "note": "Full MCP protocol support coming soon",
            "server": server.name()
        }
    }).to_string())
}
