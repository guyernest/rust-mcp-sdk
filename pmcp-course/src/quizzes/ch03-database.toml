# Quiz: Database MCP Servers

id = "ch03-database"
title = "Database MCP Servers"
lesson_id = "ch03"
pass_threshold = 0.7

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why should MCP database servers only allow SELECT queries by default?"
prompt.distractors = [
    "SELECT queries are faster than other queries",
    "Other query types aren't supported by MCP",
    "SELECT is the only SQL command that returns data"
]
answer.answer = "To prevent accidental or malicious data modification"
context = """
Security is paramount in enterprise MCP servers. By restricting to SELECT queries,
you prevent users (or AI) from accidentally or intentionally modifying or deleting data.
Write operations should require explicit, separate tools with proper authorization.
"""
id = "43554326-22af-4c94-ae41-dfa5ef8b8d81"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is SQL injection and why is it dangerous?"
prompt.distractors = [
    "A way to speed up database queries",
    "A technique to compress SQL statements",
    "A method for caching database results"
]
answer.answer = "An attack where malicious SQL is inserted into queries"
context = """
SQL injection occurs when user input is directly concatenated into SQL queries.
An attacker can craft input that changes the query's meaning, potentially
accessing unauthorized data or modifying the database. Always use parameterized queries.
"""
id = "7d07a99a-13de-42e2-92de-eb107b5addb6"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Rust crate is commonly used for type-safe async SQL queries?"
answer.answer = "sqlx"
answer.alternatives = ["SQLx", "SQLX"]
context = """
sqlx is a popular async SQL crate that provides compile-time checked queries,
connection pooling, and support for PostgreSQL, MySQL, and SQLite.
"""
id = "5d5eb6e5-1dab-495f-8d9f-6dd5cffb55fa"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What type of data is best suited for MCP Resources in a database server?"
prompt.distractors = [
    "Customer records like db://customers/12345",
    "Dynamic search results from user queries",
    "Aggregated analytics and reports"
]
answer.answer = "Schema documentation and reference data like db://schema or db://reference/genres"
context = """
Resources are best for documentation and metadata: database schemas, reference lookup tables
(genres, countries, status codes), and query examples. Entity lookups like db://customers/12345
should use tools because tools offer more flexibility for joins, aggregations, and filtering.
"""
id = "e428c402-a71d-462a-afc2-ee531ab77cf1"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What should you always add to database queries to prevent memory issues?"
prompt.distractors = [
    "ORDER BY clause",
    "DISTINCT keyword",
    "GROUP BY clause"
]
answer.answer = "LIMIT clause"
context = """
Always add a LIMIT clause to prevent queries from returning millions of rows
and exhausting server memory. A reasonable default (e.g., 100-1000 rows) with
a maximum limit protects both the server and the user experience.
"""
id = "ad853d09-350f-4c86-8c33-3c653e62eda9"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why are Tools preferred over Resources for entity lookups like getting customer data?"
prompt.distractors = [
    "Resources can't return JSON data",
    "Tools are faster than resources",
    "Resources don't support caching"
]
answer.answer = "Tools allow flexible queries with joins, aggregations, and filtering in one call"
context = """
With tools, Claude can write a single query that joins customer data with orders,
calculates totals, and filters results. With resources like db://customers/12345,
you'd need multiple separate calls and couldn't do aggregations or complex joins.
"""
id = "b7c3d4e5-f6a7-4892-93b4-c5d6e7f8a9b0"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is a key benefit of exposing database schema as an MCP Resource?"
prompt.distractors = [
    "It makes queries run faster",
    "It encrypts sensitive data",
    "It automatically indexes tables"
]
answer.answer = "Claude can understand the database structure before writing queries"
context = """
When Claude reads db://schema, it learns all table names, column types, and relationships
in one call. This reduces the need for exploratory queries like PRAGMA table_info()
and helps Claude write better, more accurate SQL on the first attempt.
"""
id = "c8d9e0f1-2a3b-4c5d-6e7f-8a9b0c1d2e3f"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Which pagination approach is better for consistent results when data is changing?"
prompt.distractors = [
    "OFFSET-based pagination with page numbers",
    "LIMIT without any offset",
    "Random sampling with ORDER BY RANDOM()"
]
answer.answer = "Cursor-based pagination using a stable column like timestamp or ID"
context = """
Offset pagination can skip or duplicate rows when data changes between requests.
Cursor-based pagination uses a WHERE clause with a stable column (e.g., WHERE id > last_id)
to ensure consistent results regardless of insertions or deletions.
"""
id = "d9e0f1a2-3b4c-5d6e-7f8a-9b0c1d2e3f4a"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What standard wrapper type in Rust is used to share a database connection pool across async tasks?"
answer.answer = "Arc"
answer.alternatives = ["Arc<>", "std::sync::Arc", "arc"]
context = """
Arc (Atomically Reference Counted) allows multiple async tasks to share ownership
of the connection pool safely. Combined with sqlx's internal connection management,
this enables efficient concurrent database access.
"""
id = "e0f1a2b3-4c5d-6e7f-8a9b-0c1d2e3f4a5b"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the recommended first layer of defense for SQL injection in a database MCP server?"
prompt.distractors = [
    "Encrypting all user input",
    "Limiting query results to 100 rows",
    "Running queries in a transaction"
]
answer.answer = "Only allowing SELECT statements through query parsing"
context = """
The first defense layer is parsing the SQL to verify it's a SELECT statement.
This prevents INSERT, UPDATE, DELETE, DROP, and other dangerous operations
before any query reaches the database.
"""
id = "f1a2b3c4-5d6e-7f8a-9b0c-1d2e3f4a5b6c"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "When building a db-explorer MCP server, how should the database connection pool be shared?"
prompt.distractors = [
    "Create a new connection for each query",
    "Store the pool in a global static variable",
    "Pass the connection string to each tool"
]
answer.answer = "Clone an Arc<SqlitePool> into each tool handler"
context = """
Using Arc<SqlitePool> allows efficient sharing of the connection pool.
Each tool can clone the Arc (cheap reference count increment) and access
the pool safely. The pool manages connection reuse internally.
"""
id = "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
