# Quiz: Identity Provider Integration

id = "ch14-providers"
title = "Enterprise Identity Provider Integration"
lesson_id = "ch14"
pass_threshold = 0.7

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the most important factor when choosing an OAuth provider for your MCP server?"
prompt.distractors = [
    "Which provider has the best documentation and developer experience",
    "Which provider offers the most features and integration options",
    "Which provider is cheapest for your expected user volume"
]
answer.answer = "Use the provider your organization already has - don't introduce a new IdP just for MCP"
answer.position = 0
context = """
The best OAuth provider is the one your organization already uses. If you have
Okta, use Okta. If you're a Microsoft 365 shop, use Entra ID. If you're AWS-native,
use Cognito. Introducing a new provider means duplicate user management, new
vendor relationships, and IT teams learning another system. The patterns work
with any OIDC-compliant provider.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781401"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "How does Auth0 differ from Cognito in its approach to permissions?"
prompt.distractors = [
    "Auth0 only supports API keys for machine-to-machine authentication",
    "Auth0 doesn't support custom permissions beyond basic read/write scopes",
    "Auth0 requires AWS IAM roles for all authorization decisions"
]
answer.answer = "Auth0 uses RBAC with a 'permissions' array in tokens, while Cognito uses groups and custom scopes"
answer.position = 1
context = """
Auth0's RBAC system places permissions directly in the 'permissions' array of
access tokens when enabled. Cognito uses 'cognito:groups' for group membership
and custom scopes defined in resource servers. Auth0's approach is more
developer-friendly; Cognito's is more AWS-integrated.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781402"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "In Cognito tokens, what claim contains the user's group memberships?"
answer.answer = "cognito:groups"
answer.alternatives = ["groups", "cognito groups", "cognito:group"]
context = """
Cognito places group memberships in the 'cognito:groups' claim as an array of
group names. Use this to implement role-based access: map group names like
'Admins' or 'Developers' to permission sets in your MCP server code.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781403"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What claim should you use as the stable user identifier in Microsoft Entra ID?"
prompt.distractors = [
    "sub - the subject claim that varies across different applications",
    "preferred_username - the UPN which can be changed by administrators",
    "email - the user's email address which may change over time"
]
answer.answer = "oid (Object ID) - the GUID that uniquely identifies the user across Microsoft services"
answer.position = 2
context = """
In Entra ID, use 'oid' (Object ID) as the stable user identifier. The 'sub'
claim may change across applications, and 'preferred_username' (UPN) can be
renamed. The 'oid' is a GUID that remains constant for the user's lifetime
across all Microsoft 365 and Azure services.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781404"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the format of the Auth0 'sub' claim?"
prompt.distractors = [
    "A UUID like Cognito generates for all user identifiers",
    "The user's email address normalized to lowercase format",
    "A numeric user ID that increments sequentially for each user"
]
answer.answer = "provider|id format like 'auth0|123456' or 'google-oauth2|789'"
answer.position = 3
context = """
Auth0's 'sub' claim uses the format 'provider|id' where provider is the identity
source (auth0, google-oauth2, samlp, etc.) and id is the user's identifier from
that provider. This format tells you how the user authenticated, useful for
handling federated identities differently.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781405"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Entra ID claim contains app roles defined in the app registration?"
answer.answer = "roles"
answer.alternatives = ["role", "app_roles", "appRoles"]
context = """
Entra ID places app roles in the 'roles' claim as an array of role values
(e.g., ['MCP.Admin', 'MCP.User']). These roles are defined in the app
registration under 'App roles' and assigned to users or groups. Unlike groups
which are GUIDs, roles are the human-readable values you defined.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781407"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "How do you add custom claims in Auth0 tokens?"
prompt.distractors = [
    "Modify the JWT directly before sending to include additional data",
    "Configure them in the API settings under custom claim definitions",
    "Set them in the client request headers during token exchange"
]
answer.answer = "Use Auth0 Actions (or Rules) to add namespaced custom claims during authentication"
answer.position = 0
context = """
Auth0 requires custom claims to use namespacing (e.g., 'https://myapp/department').
Use Actions (modern) or Rules (legacy) to add these claims during the login flow.
Actions run JavaScript code that can access user metadata, event context, and
external APIs to enrich tokens with custom claims.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781408"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "When should you implement multi-tenancy for your MCP server?"
prompt.distractors = [
    "When you have multiple departments in your organization using different tools",
    "When you need role-based access control for users within your company",
    "When you want to isolate dev/staging/prod environments for deployment safety"
]
answer.answer = "When building a SaaS platform serving multiple external organizations from shared infrastructure"
answer.position = 1
context = """
Most organizations don't need multi-tenancy. If all users come from the same
organization (even different departments), use your IdP's groups and roles instead.
Multi-tenancy is for SaaS platforms where Organization A and Organization B
share the same server but must never see each other's data. It adds significant
complexity: tenant isolation at every layer, provisioning, cross-tenant attack surfaces.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781410"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "How do Entra ID groups appear in JWT tokens compared to Auth0?"
prompt.distractors = [
    "Both use group names directly in the token claims array",
    "Auth0 uses GUIDs for groups, Entra uses human-readable names",
    "Neither includes groups by default without explicit configuration"
]
answer.answer = "Entra uses GUIDs (requiring mapping to permissions), Auth0 uses organization features or custom claims"
answer.position = 2
context = """
Entra ID includes group GUIDs in the 'groups' claim, not human-readable names.
You must maintain a mapping from GUIDs to permissions. Auth0 uses Organizations
for multi-tenancy or custom claims for groups. Neither approach is automatic;
both require configuration and mapping code.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781411"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Auth0 feature provides built-in multi-tenant (B2B) support?"
answer.answer = "Organizations"
answer.alternatives = ["organizations", "Auth0 Organizations", "org"]
context = """
Auth0 Organizations is the built-in feature for B2B multi-tenancy. It provides
org_id and org_name claims in tokens, per-organization settings, member
management, and branded login pages. Enable Organizations in your Auth0
Application settings and use org_id as the tenant identifier.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781412"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is schema-per-tenant isolation?"
prompt.distractors = [
    "Different database servers per tenant for maximum isolation",
    "Separate tables within one schema using tenant prefix naming",
    "Different S3 buckets per tenant for object storage isolation"
]
answer.answer = "Each tenant gets a separate database schema with isolated tables within one database"
answer.position = 3
context = """
Schema-per-tenant creates a database schema (namespace) for each tenant:
tenant_abc.resources, tenant_xyz.resources. All tenants share one database
server but have completely isolated tables. Use SET search_path to switch
schemas per request. Balances isolation with operational simplicity.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781413"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What PostgreSQL feature provides row-level tenant isolation in shared tables?"
prompt.distractors = [
    "Table partitioning to separate tenant data into physical segments",
    "Foreign key constraints that enforce referential integrity between tenants",
    "Check constraints that validate tenant_id values on insert operations"
]
answer.answer = "Row Level Security (RLS) with policies that filter by tenant_id"
answer.position = 0
context = """
PostgreSQL RLS creates policies that automatically filter queries by tenant.
Enable with ALTER TABLE ENABLE ROW LEVEL SECURITY, then create a policy:
CREATE POLICY tenant_isolation USING (tenant_id = current_setting('app.tenant_id')).
Set the tenant context per request; RLS handles filtering transparently.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781414"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the On-Behalf-Of (OBO) flow in Entra ID?"
prompt.distractors = [
    "Admin impersonating a user for troubleshooting and support purposes",
    "Service account authentication for background jobs and scheduled tasks",
    "User delegating to another user for temporary access permissions"
]
answer.answer = "A service exchanging a user's token for a new token to call downstream APIs as that user"
answer.position = 1
context = """
On-Behalf-Of flow allows Service A to call Service B using the original user's
identity. Service A exchanges the user's token for a new token scoped to Service
B. This maintains user context through the call chain rather than switching to
service identity. Use grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer.
"""
id = "f14a2b3c-d4e5-6789-abcd-123456781415"
