# Quiz: Cloudflare Workers Deployment

id = "ch09-cloudflare"
title = "Cloudflare Workers WASM Deployment"
lesson_id = "ch09"
pass_threshold = 0.7

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What runtime technology enables Cloudflare Workers to achieve sub-5ms cold starts?"
prompt.distractors = [
    "Docker containers with pre-warmed images",
    "Firecracker microVMs with snapshot restore",
    "JIT-compiled JavaScript with caching"
]
answer.answer = "V8 isolates that spin up in microseconds with shared V8 engine overhead"
context = """
Workers uses V8 isolates, not containers. Multiple isolates share one V8 engine
instance, eliminating per-request engine startup. An isolate is just a JavaScript
execution context with its own memory - creating one takes microseconds. WASM
modules are also pre-compiled, further reducing startup time.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780901"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Rust compilation target is used for Cloudflare Workers?"
answer.answer = "wasm32-unknown-unknown"
answer.alternatives = ["wasm32", "WASM32", "wasm-unknown-unknown"]
context = """
Rust compiles to wasm32-unknown-unknown for WebAssembly targets. This produces
a .wasm binary that V8 can execute. Install with: rustup target add wasm32-unknown-unknown.
The 'unknown-unknown' indicates no specific OS or vendor - it's a bare WASM target.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780902"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why can't standard async runtimes like tokio be used in Cloudflare Workers?"
prompt.distractors = [
    "Workers only supports synchronous code execution",
    "tokio requires more than 128MB of memory",
    "Workers uses JavaScript for all async operations"
]
answer.answer = "tokio relies on system calls (epoll/kqueue) that don't exist in the WASM sandbox"
context = """
WASM runs in a sandboxed environment without access to OS system calls. tokio's
I/O reactor uses epoll (Linux) or kqueue (macOS) for async I/O - these don't
exist in WASM. Instead, Workers provides async through JavaScript promises that
bridge to the V8 event loop. Use wasm-bindgen-futures for async in Workers.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780903"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Workers binding provides key-value storage for caching MCP results?"
prompt.distractors = [
    "R2 for large object storage",
    "D1 for SQLite database queries",
    "Durable Objects for coordination"
]
answer.answer = "KV (Workers KV) for globally distributed key-value storage with eventual consistency"
context = """
Workers KV stores key-value pairs replicated across Cloudflare's edge network.
Reads are fast (~10ms) from any edge location. Writes are eventually consistent
(~60 seconds to propagate globally). Use KV for caching tool results, session
data, or configuration. Bind in wrangler.toml with [[kv_namespaces]].
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780904"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the maximum memory available to a Cloudflare Worker?"
prompt.distractors = [
    "256 MB with paid plan",
    "512 MB with Enterprise",
    "1 GB with custom limits"
]
answer.answer = "128 MB for both free and paid plans"
context = """
Workers have a hard 128MB memory limit - this cannot be increased on any plan.
This constraint requires careful design: streaming large datasets instead of
buffering, using external storage (KV, R2) for large objects, and avoiding
memory-heavy dependencies. Rust's zero-cost abstractions help stay within limits.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780905"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What CLI tool is used to develop and deploy Cloudflare Workers?"
answer.answer = "wrangler"
answer.alternatives = ["Wrangler", "npx wrangler", "wrangler cli"]
context = """
Wrangler is Cloudflare's CLI for Workers development. Commands include:
wrangler dev (local development server), wrangler deploy (publish to Cloudflare),
wrangler tail (stream logs), and wrangler secret (manage secrets). Install with
npm install -g wrangler. For Rust, also use worker-build for WASM compilation.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780906"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Cargo.toml crate-type is required for Cloudflare Workers?"
prompt.distractors = [
    "staticlib for static linking",
    "rlib for Rust library",
    "bin for executable binary"
]
answer.answer = "cdylib for C-compatible dynamic library that compiles to WASM"
context = """
WASM requires crate-type = ['cdylib'] in Cargo.toml. This produces a dynamic
library with C-compatible exports that wasm-bindgen can process. The resulting
.wasm file contains exported functions that JavaScript can call. Don't use 'bin'
or 'lib' - they won't produce the correct WASM output format.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780907"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "How should you handle random number generation in WASM for MCP servers?"
prompt.distractors = [
    "Use std::rand which works natively in WASM",
    "Import random numbers from JavaScript globals",
    "Avoid randomness since WASM is deterministic"
]
answer.answer = "Use the getrandom crate with the 'js' feature to bridge to Web Crypto API"
context = """
WASM has no native random source - std::rand panics without configuration.
The getrandom crate with features = ['js'] bridges to JavaScript's crypto.getRandomValues(),
which uses the Web Crypto API. This enables uuid generation, cryptographic operations,
and any crate that depends on randomness (like rand).
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780908"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Workers binding connects to PostgreSQL databases?"
prompt.distractors = [
    "Workers KV with SQL adapter",
    "D1 with PostgreSQL compatibility mode",
    "Cloudflare Tunnel with direct connection"
]
answer.answer = "Hyperdrive, which provides connection pooling and caching for external databases"
context = """
Hyperdrive connects Workers to external PostgreSQL, MySQL, or other databases.
It maintains connection pools at Cloudflare's edge, eliminating per-request
connection overhead. Queries are routed through Cloudflare's network, and
results can be cached. Configure with [[hyperdrive]] in wrangler.toml.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780909"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why is binary size optimization critical for Cloudflare Workers?"
prompt.distractors = [
    "Workers charge per KB of deployed code",
    "Large binaries exceed the 1MB WASM limit",
    "Binary size affects monthly billing rates"
]
answer.answer = "Larger WASM binaries take longer to parse and compile, increasing cold start times"
context = """
V8 must parse and compile WASM on first load. A 100KB binary parses in ~1ms;
a 3MB binary takes ~12ms. While still fast, keeping binaries under 1MB ensures
consistent sub-20ms cold starts. Use opt-level='s', LTO, and strip symbols.
The worker size limit is 10MB compressed, but smaller is faster.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780910"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Workers binding provides SQLite database access at the edge?"
answer.answer = "D1"
answer.alternatives = ["d1", "Workers D1", "Cloudflare D1"]
context = """
D1 is Cloudflare's serverless SQLite database. It runs at the edge, providing
low-latency queries without external database connections. D1 supports standard
SQL, automatic replication, and point-in-time recovery. Bind with [[d1_databases]]
in wrangler.toml and access via env.DB in your Worker code.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780911"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the primary advantage of Cloudflare Workers' global edge deployment?"
prompt.distractors = [
    "Lower compute costs than regional deployment",
    "Automatic failover between data centers",
    "Support for larger memory allocations"
]
answer.answer = "Requests are handled by the nearest of 300+ edge locations, minimizing latency globally"
context = """
Workers run on Cloudflare's edge network with 300+ points of presence worldwide.
User requests are routed to the nearest location - a user in Tokyo connects to
a Tokyo edge server, not a US-central server. This provides sub-50ms response
times globally, compared to 200-500ms for single-region deployments.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780912"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "How do you store secrets like API keys in Cloudflare Workers?"
prompt.distractors = [
    "In wrangler.toml under [vars] section",
    "As environment variables in the dashboard",
    "In a .env file deployed with the worker"
]
answer.answer = "Using 'wrangler secret put' which encrypts and stores secrets separately from code"
context = """
Worker secrets are encrypted and stored separately from your code. Use
'wrangler secret put API_KEY' to add secrets - they're never visible in
wrangler.toml or the dashboard. In code, access via env.API_KEY. Secrets
are injected at runtime, not compile time, keeping them out of your WASM binary.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780913"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What feature of the chrono crate must be enabled for WASM compatibility?"
prompt.distractors = [
    "std for standard library support",
    "serde for serialization",
    "clock for time access"
]
answer.answer = "wasmbind to bridge JavaScript Date API for time operations"
context = """
The chrono crate needs features = ['wasmbind'] for WASM. Without it, chrono
cannot access system time because WASM has no native clock. The wasmbind feature
bridges to JavaScript's Date object for current time operations. Similarly, uuid
needs features = ['js', 'v4'] for WASM random UUID generation.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780914"
