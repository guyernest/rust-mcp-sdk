# Quiz: Cloudflare Workers Deployment

id = "ch09-cloudflare"
title = "Cloudflare Workers WASM Deployment"
lesson_id = "ch09"
pass_threshold = 0.7

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What runtime technology enables Cloudflare Workers to achieve sub-5ms cold starts?"
prompt.distractors = [
    "Docker containers with pre-warmed images for instant startup",
    "Firecracker microVMs with snapshot restore for fast initialization",
    "JIT-compiled JavaScript with caching for reduced parsing overhead"
]
answer.answer = "V8 isolates that spin up in microseconds with shared V8 engine overhead"
answer.position = 1
context = """
Workers uses V8 isolates, not containers. Multiple isolates share one V8 engine
instance, eliminating per-request engine startup. An isolate is just a JavaScript
execution context with its own memory - creating one takes microseconds. WASM
modules are also pre-compiled, further reducing startup time.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780901"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What Rust compilation target is used for Cloudflare Workers?"
answer.answer = "wasm32-unknown-unknown"
answer.alternatives = ["wasm32", "WASM32", "wasm-unknown-unknown"]
context = """
Rust compiles to wasm32-unknown-unknown for WebAssembly targets. This produces
a .wasm binary that V8 can execute. Install with: rustup target add wasm32-unknown-unknown.
The 'unknown-unknown' indicates no specific OS or vendor - it's a bare WASM target.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780902"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why can't standard async runtimes like tokio be used in Cloudflare Workers?"
prompt.distractors = [
    "Workers only supports synchronous code execution for simplicity",
    "tokio requires more than 128MB of memory to initialize properly",
    "Workers uses JavaScript for all async operations through its API"
]
answer.answer = "tokio relies on system calls (epoll/kqueue) that don't exist in the WASM sandbox"
answer.position = 2
context = """
WASM runs in a sandboxed environment without access to OS system calls. tokio's
I/O reactor uses epoll (Linux) or kqueue (macOS) for async I/O - these don't
exist in WASM. Instead, Workers provides async through JavaScript promises that
bridge to the V8 event loop. Use wasm-bindgen-futures for async in Workers.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780903"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Workers binding provides key-value storage for caching MCP results?"
prompt.distractors = [
    "R2 for large object storage with S3-compatible API access",
    "D1 for SQLite database queries with SQL-based data access",
    "Durable Objects for coordination and stateful operations"
]
answer.answer = "KV (Workers KV) for globally distributed key-value storage with eventual consistency"
answer.position = 3
context = """
Workers KV stores key-value pairs replicated across Cloudflare's edge network.
Reads are fast (~10ms) from any edge location. Writes are eventually consistent
(~60 seconds to propagate globally). Use KV for caching tool results, session
data, or configuration. Bind in wrangler.toml with [[kv_namespaces]].
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780904"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the maximum memory available to a Cloudflare Worker?"
prompt.distractors = [
    "256 MB with paid plan upgrade",
    "512 MB with Enterprise contract",
    "1 GB with custom limits negotiation"
]
answer.answer = "128 MB for both free and paid plans"
answer.position = 0
context = """
Workers have a hard 128MB memory limit - this cannot be increased on any plan.
This constraint requires careful design: streaming large datasets instead of
buffering, using external storage (KV, R2) for large objects, and avoiding
memory-heavy dependencies. Rust's zero-cost abstractions help stay within limits.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780905"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Cargo.toml crate-type is required for Cloudflare Workers?"
prompt.distractors = [
    "staticlib for static linking into C programs",
    "rlib for Rust library used by other crates",
    "bin for executable binary applications"
]
answer.answer = "cdylib for C-compatible dynamic library that compiles to WASM"
answer.position = 1
context = """
WASM requires crate-type = ['cdylib'] in Cargo.toml. This produces a dynamic
library with C-compatible exports that wasm-bindgen can process. The resulting
.wasm file contains exported functions that JavaScript can call. Don't use 'bin'
or 'lib' - they won't produce the correct WASM output format.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780907"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What Workers binding connects to PostgreSQL databases?"
prompt.distractors = [
    "Workers KV with SQL adapter for query translation",
    "D1 with PostgreSQL compatibility mode enabled",
    "Cloudflare Tunnel with direct connection through VPN"
]
answer.answer = "Hyperdrive, which provides connection pooling and caching for external databases"
answer.position = 2
context = """
Hyperdrive connects Workers to external PostgreSQL, MySQL, or other databases.
It maintains connection pools at Cloudflare's edge, eliminating per-request
connection overhead. Queries are routed through Cloudflare's network, and
results can be cached. Configure with [[hyperdrive]] in wrangler.toml.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780909"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why is binary size optimization critical for Cloudflare Workers?"
prompt.distractors = [
    "Workers charge per KB of deployed code for storage costs",
    "Large binaries exceed the 1MB WASM limit imposed by V8",
    "Binary size affects monthly billing rates for compute usage"
]
answer.answer = "Larger WASM binaries take longer to parse and compile, increasing cold start times"
answer.position = 3
context = """
V8 must parse and compile WASM on first load. A 100KB binary parses in ~1ms;
a 3MB binary takes ~12ms. While still fast, keeping binaries under 1MB ensures
consistent sub-20ms cold starts. Use opt-level='s', LTO, and strip symbols.
The worker size limit is 10MB compressed, but smaller is faster.
"""
id = "c9d3e4f5-a6b7-8901-cdef-123456780910"
