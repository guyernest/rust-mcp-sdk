# Quiz: Server Composition

id = "ch19-composition"
title = "Server Composition: Foundation, Domain, and Orchestration Patterns"
lesson_id = "ch19"
pass_threshold = 0.7

[[questions]]
type = "MultipleChoice"
prompt.prompt = "When should an organization consider implementing server composition patterns?"
prompt.distractors = [
    "When building their first MCP server as a learning exercise",
    "When a single team owns all MCP servers with unified codebase",
    "When servers only run in development environments for testing purposes"
]
answer.answer = "When they have 10+ MCP servers across teams with duplicated functionality"
answer.position = 0
context = """
Server composition is an advanced pattern that adds complexity. It becomes valuable when you have
many servers (10+), see duplicated code (like auth validation in every server), have discovery
problems ("does anyone have a tool that does X?"), or need domain-specific hierarchies. For small
deployments with few servers, the overhead isn't justified.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790001"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What does the DRY principle mean in the context of MCP server development?"
prompt.distractors = [
    "Delete Redundant YAML - remove duplicate configuration files from deployments",
    "Disable Remote Yields - prevent async operations from blocking threads",
    "Direct Request Yielding - pass requests without processing or validation"
]
answer.answer = "Don't Repeat Yourself - write common functionality once in foundation servers, reuse everywhere"
answer.position = 1
context = """
DRY (Don't Repeat Yourself) in MCP means writing shared functionality (authentication, database
access, file operations) once in foundation servers instead of duplicating it across every domain
server. When auth logic lives in one place, bug fixes and updates automatically apply everywhere,
and teams can focus on domain-specific business logic.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790002"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Which is NOT a characteristic of a good foundation server?"
prompt.distractors = [
    "Stable APIs that rarely change to avoid breaking downstream consumers",
    "Generic with no business-specific logic keeping concerns separated cleanly",
    "Well-tested since bugs affect all consumers throughout the organization"
]
answer.answer = "Contains department-specific business rules and calculations"
answer.position = 2
context = """
Foundation servers should be: STABLE (breaking changes affect all domains), GENERIC (no business
logic), COMPOSABLE (combine easily with other foundations), WELL-TESTED (bugs cascade everywhere),
and DOCUMENTED (clear contracts). Business rules, domain calculations, and department-specific
logic belong in domain servers, not foundations.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790003"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is a good candidate for a foundation server?"
prompt.distractors = [
    "Budget forecasting calculations specific to the finance department needs",
    "Employee promotion workflows managed by the human resources team",
    "Customer pricing rules that vary by region and contract terms"
]
answer.answer = "Authentication, database connectivity, and file system access"
answer.position = 3
context = """
Good foundation candidates are cross-cutting infrastructure concerns: authentication/authorization,
database connectivity, file system access, HTTP client operations, caching, logging/metrics. These
are stable, generic capabilities every domain needs. Business-specific items like budget forecasts,
HR workflows, or pricing rules are domain server concerns.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790004"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "In the three-tier server composition hierarchy, what is the role of domain servers?"
prompt.distractors = [
    "Provide raw database and file access to all servers in the hierarchy",
    "Orchestrate complex workflows spanning multiple departments and teams",
    "Define authentication and authorization rules for the entire organization"
]
answer.answer = "Build business-specific tools using foundation components for a specific department or capability"
answer.position = 0
context = """
The three tiers are: Foundation (core building blocks like auth, database, files), Domain
(business-specific servers for Finance, HR, Engineering that compose foundations), and
Orchestration (cross-domain workflows). Domain servers own business logic like expense_report,
employee_lookup, or deploy_service, built on top of shared foundation capabilities.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790005"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What security measure should a FileSystemFoundation implement to prevent directory traversal attacks?"
prompt.distractors = [
    "Check file extension only to block dangerous executable file types",
    "Limit file size to 10MB to prevent resource exhaustion attacks",
    "Require admin authentication before allowing any file system operations"
]
answer.answer = "Validate that the canonical path starts with the allowed base path"
answer.position = 1
context = """
Directory traversal attacks use '../' sequences to escape allowed directories (../../etc/passwd).
FileSystemFoundation should canonicalize the requested path and verify it still starts_with the
base path. Combined with extension allowlists and size limits, this creates defense in depth.
The foundation handles this once so domain servers don't implement it incorrectly.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790006"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What problem does cross-domain communication solve?"
prompt.distractors = [
    "Reducing network latency between servers through optimized routing paths",
    "Enforcing consistent error messages across all domain server implementations",
    "Minimizing database connection pools by sharing connections across domains"
]
answer.answer = "Enabling tasks that require tools from multiple domains, like onboarding needing HR + Engineering + Finance"
answer.position = 2
context = """
Some workflows span multiple domains: employee onboarding needs HR (create employee record),
Engineering (provision accounts), and Finance (set up payroll). Cross-domain communication
patterns include orchestration servers (coordinate multiple domains), shared events (domains
publish/subscribe), and gateway servers (single entry point routing to appropriate domains).
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790009"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the key difference between orchestration and direct tool calls?"
prompt.distractors = [
    "Orchestration is faster because it skips validation and authorization checks",
    "Direct calls support more tool types including streaming and async operations",
    "Orchestration only works with synchronous tools and blocks on each step"
]
answer.answer = "Orchestration defines workflows that execute server-side with guaranteed step sequencing"
answer.position = 3
context = """
Direct tool calls: AI decides what to call, when, and in what order - flexible but unpredictable.
Orchestration: predefined workflows execute server-side with deterministic step order. Workflows
guarantee: Step 2 always follows Step 1, rollback on failure, audit logging, and consistent
behavior regardless of which AI client invokes them. Critical for compliance-sensitive operations.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790011"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "When should you NOT use orchestration patterns?"
prompt.distractors = [
    "When workflows need guaranteed execution order for compliance requirements",
    "When audit trails are required for compliance and regulatory reporting",
    "When multiple domains must coordinate to complete a business transaction"
]
answer.answer = "When the AI needs flexibility to explore different approaches based on intermediate results"
answer.position = 0
context = """
Orchestration trades flexibility for predictability. Don't use it when: the AI should explore
multiple approaches, steps depend heavily on context the AI discovered, workflows are highly
variable per user, or the interaction is conversational. For research tasks or exploratory
debugging, let the AI call tools directly rather than constraining it to fixed workflows.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790012"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "What is the purpose of domain-specific types in domain servers?"
prompt.distractors = [
    "To make JSON serialization faster through optimized binary representations",
    "To reduce memory usage in large datasets by using compact field layouts",
    "To enable automatic database schema generation from Rust struct definitions"
]
answer.answer = "To provide compile-time safety and clear contracts for domain concepts like Employee or Expense"
answer.position = 1
context = """
Domain-specific types (struct Employee, struct ExpenseReport, enum ApprovalStatus) provide:
compile-time validation (can't pass Order to employee tools), self-documenting APIs through
JsonSchema derive, clear ownership boundaries between domains, and type-safe tool inputs/outputs.
Serde + JsonSchema derive macros enable automatic JSON handling and schema generation for AI clients.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790014"

[[questions]]
type = "ShortAnswer"
prompt.prompt = "What PMCP struct represents a complete workflow with multiple connected steps?"
answer.answer = "SequentialWorkflow"
answer.alternatives = ["Workflow", "sequential workflow", "Sequential Workflow"]
context = """
SequentialWorkflow defines a series of WorkflowStep operations that execute in order. Each step
references a tool, specifies parameter bindings (from input or previous steps), and can include
conditions. The workflow validates at build time that all step references exist and types match.
Server-side execution ensures consistent behavior across all AI clients.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790015"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "Why should foundations be thoroughly tested more than typical code?"
prompt.distractors = [
    "Foundation tests run faster than domain tests due to simpler logic paths",
    "Foundations are required to have 100% coverage by law for enterprise software",
    "Testing foundations generates better documentation through doctest integration"
]
answer.answer = "Bugs in foundations affect all consuming domain servers, cascading failures across the organization"
answer.position = 2
context = """
A bug in AuthFoundation affects every domain server that composes it - potentially breaking all
MCP servers in the organization simultaneously. Foundations need comprehensive tests: unit tests
for each method, integration tests for common compositions, security tests (like path traversal
prevention), and property-based tests for edge cases. The investment in testing foundations
pays dividends in stability across all dependent domains.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790016"

[[questions]]
type = "MultipleChoice"
prompt.prompt = "In server composition, what ensures that a domain server has all required foundations at startup?"
prompt.distractors = [
    "Runtime duck typing - check if methods exist when called at execution time",
    "Configuration files listing required services that must be present at startup",
    "Environment variables specifying foundation URLs for service discovery purposes"
]
answer.answer = "Rust's type system - foundations are passed as typed parameters, missing ones cause compile errors"
answer.position = 3
context = """
Domain servers take foundation parameters with explicit types: create_finance_server(auth:
Arc<AuthFoundation>, db: Arc<DatabaseFoundation>). Missing a required foundation is a compile
error, not a runtime failure. Combined with foundation versioning checks, this ensures domain
servers have compatible foundations before they start serving requests.
"""
id = "f19a1b2c-d3e4-5678-abcd-123456790018"
