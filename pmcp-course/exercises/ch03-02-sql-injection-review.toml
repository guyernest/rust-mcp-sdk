# Exercise: SQL Injection Code Review
#
# This code review exercise focuses on SQL injection vulnerabilities -
# one of the most critical security issues in database applications.

[exercise]
id = "ch03-02-sql-injection-review"
title = "Code Review: SQL Injection Vulnerabilities"
type = "code_review"
chapter = "ch03"
difficulty = "intermediate"
estimated_minutes = 25
prerequisites = ["ch03-01-db-query-basics", "ch02-03-code-review-basics"]

[exercise.context]
description = """
You've been asked to review a database query tool before it goes to production.
The developer is new to security and made several classic mistakes. SQL injection
vulnerabilities can lead to data breaches, data loss, and complete system compromise.

This exercise builds on your code review skills from Chapter 2, now with a
security focus. SQL injection is consistently in the OWASP Top 10 - it's one
of the most common and dangerous vulnerabilities in web applications.

Your task: Identify ALL security vulnerabilities, categorize them by severity,
and propose secure alternatives using parameterized queries.
"""

[exercise.learning_objectives]
thinking = [
    "How SQL injection attacks work and why they're dangerous",
    "Why string concatenation for SQL is always wrong",
    "The difference between blocklisting and allowlisting",
]

doing = [
    "Identify multiple SQL injection vulnerabilities",
    "Propose fixes using parameterized queries",
    "Recognize insufficient security controls",
]

[exercise.code_to_review]
language = "rust"
code = """
//! User Search MCP Server
//!
//! Provides tools to search and filter user data.

use pmcp::{Server, ServerCapabilities, ToolCapabilities};
use pmcp::server::TypedTool;
use serde::{Deserialize, Serialize};
use schemars::JsonSchema;
use sqlx::{Pool, Sqlite};
use std::sync::Arc;

type DbPool = Arc<Pool<Sqlite>>;

#[derive(Deserialize, JsonSchema)]
struct SearchUsersInput {
    /// Name to search for
    name: Option<String>,
    /// Email domain to filter (e.g., "company.com")
    email_domain: Option<String>,
    /// Minimum user ID
    min_id: Option<i64>,
    /// Sort column
    sort_by: Option<String>,
    /// Sort direction
    sort_order: Option<String>,
}

#[derive(Serialize)]
struct User {
    id: i64,
    name: String,
    email: String,
    role: String,
}

async fn search_users(pool: &DbPool, input: SearchUsersInput) -> anyhow::Result<Vec<User>> {
    let mut query = String::from("SELECT id, name, email, role FROM users WHERE 1=1");

    // Add name filter
    if let Some(name) = &input.name {
        // Filter out obvious SQL injection attempts
        if !name.contains("DROP") && !name.contains("DELETE") {
            query.push_str(&format!(" AND name LIKE '%{}%'", name));
        }
    }

    // Add email domain filter
    if let Some(domain) = &input.email_domain {
        query.push_str(&format!(" AND email LIKE '%@{}'", domain));
    }

    // Add minimum ID filter
    if let Some(min_id) = input.min_id {
        query.push_str(&format!(" AND id >= {}", min_id));
    }

    // Add sorting
    if let Some(sort_by) = &input.sort_by {
        query.push_str(&format!(" ORDER BY {}", sort_by));

        if let Some(order) = &input.sort_order {
            if order == "desc" || order == "DESC" {
                query.push_str(" DESC");
            }
        }
    }

    // Execute the query
    let rows: Vec<(i64, String, String, String)> = sqlx::query_as(&query)
        .fetch_all(pool.as_ref())
        .await?;

    Ok(rows.into_iter().map(|(id, name, email, role)| {
        User { id, name, email, role }
    }).collect())
}

#[derive(Deserialize, JsonSchema)]
struct GetUserInput {
    /// User ID to retrieve
    user_id: String,
}

async fn get_user(pool: &DbPool, input: GetUserInput) -> anyhow::Result<User> {
    let query = format!(
        "SELECT id, name, email, role FROM users WHERE id = {}",
        input.user_id
    );

    let row: (i64, String, String, String) = sqlx::query_as(&query)
        .fetch_one(pool.as_ref())
        .await?;

    Ok(User {
        id: row.0,
        name: row.1,
        email: row.2,
        role: row.3,
    })
}

#[derive(Deserialize, JsonSchema)]
struct UpdateNicknameInput {
    user_id: i64,
    nickname: String,
}

async fn update_nickname(pool: &DbPool, input: UpdateNicknameInput) -> anyhow::Result<String> {
    // This is a read-only server, but we have this for admin use
    let query = format!(
        "UPDATE users SET nickname = '{}' WHERE id = {}",
        input.nickname, input.user_id
    );

    sqlx::query(&query)
        .execute(pool.as_ref())
        .await?;

    Ok("Nickname updated".to_string())
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let pool: DbPool = Arc::new(
        sqlx::sqlite::SqlitePoolOptions::new()
            .connect("sqlite:users.db")
            .await?
    );

    let pool_search = pool.clone();
    let pool_get = pool.clone();
    let pool_update = pool.clone();

    let server = Server::builder()
        .name("user-search")
        .version("1.0.0")
        .capabilities(ServerCapabilities {
            tools: Some(ToolCapabilities::default()),
            ..Default::default()
        })
        .tool("search_users", TypedTool::new("search_users", move |input: SearchUsersInput| {
            let pool = pool_search.clone();
            Box::pin(async move {
                let users = search_users(&pool, input).await?;
                Ok(serde_json::to_value(users)?)
            })
        }))
        .tool("get_user", TypedTool::new("get_user", move |input: GetUserInput| {
            let pool = pool_get.clone();
            Box::pin(async move {
                let user = get_user(&pool, input).await?;
                Ok(serde_json::to_value(user)?)
            })
        }))
        .tool("update_nickname", TypedTool::new("update_nickname", move |input: UpdateNicknameInput| {
            let pool = pool_update.clone();
            Box::pin(async move {
                let result = update_nickname(&pool, input).await?;
                Ok(serde_json::to_value(result)?)
            })
        }))
        .build()?;

    println!("User search server ready!");
    Ok(())
}
"""

[exercise.review_guidance]
categories = [
    "SQL Injection",
    "Input Validation",
    "Authorization/Access Control",
    "Data Exposure",
    "Defense in Depth",
]

minimum_issues = 7

severity_guide = """
- **Critical**: Direct SQL injection, data breach possible
- **High**: Indirect injection, privilege escalation possible
- **Medium**: Information disclosure, DoS potential
- **Low**: Missing best practices, defense in depth gaps
"""

[exercise.known_issues]
issues = [
    {
        severity = "critical",
        category = "SQL Injection",
        description = "Name filter uses string concatenation - direct SQL injection",
        line_hint = "query.push_str(&format!(\" AND name LIKE '%{}%'\", name));",
        explanation = """
An attacker can inject arbitrary SQL:
- Input: `'; DROP TABLE users; --`
- Result: `SELECT ... WHERE name LIKE '%'; DROP TABLE users; --%'`

The blocklist check for "DROP" and "DELETE" is trivially bypassed:
- Use lowercase: `drop`, `delete`
- Use encoding: URL encode, Unicode variations
- Use SQL comments: `DR/**/OP`
"""
    },
    {
        severity = "critical",
        category = "SQL Injection",
        description = "Email domain filter - SQL injection via domain parameter",
        line_hint = "query.push_str(&format!(\" AND email LIKE '%@{}'\", domain));",
        explanation = """
No validation on the domain parameter:
- Input: `' OR '1'='1' --`
- Result: Shows all users regardless of domain

Even worse:
- Input: `' UNION SELECT password, '', '', '' FROM credentials --`
- Result: Leaks data from other tables
"""
    },
    {
        severity = "critical",
        category = "SQL Injection",
        description = "Sort column allows injection",
        line_hint = "query.push_str(&format!(\" ORDER BY {}\", sort_by));",
        explanation = """
ORDER BY injection is often overlooked:
- Input: `(CASE WHEN (SELECT password FROM admin LIMIT 1) LIKE 'a%' THEN name ELSE email END)`
- Result: Boolean-based blind SQL injection - can extract any data character by character

Or simpler:
- Input: `1; DROP TABLE users --`
"""
    },
    {
        severity = "critical",
        category = "SQL Injection",
        description = "get_user uses string type for ID - allows injection",
        line_hint = "format!(\"SELECT ... WHERE id = {}\", input.user_id)",
        explanation = """
user_id is a String, not an integer:
- Input: `1 OR 1=1`
- Result: Returns all users

Or:
- Input: `1 UNION SELECT id, password, email, role FROM admin_users`
"""
    },
    {
        severity = "critical",
        category = "SQL Injection",
        description = "update_nickname has write injection in a 'read-only' server",
        line_hint = "format!(\"UPDATE users SET nickname = '{}' WHERE id = {}\", ...)",
        explanation = """
The comment says "read-only server" but this tool writes to the database!
- Input nickname: `', role='admin' WHERE id=1 --`
- Result: Privilege escalation - can make any user an admin

This is both injection AND access control failure.
"""
    },
    {
        severity = "high",
        category = "Input Validation",
        description = "Blocklist approach for SQL injection is fundamentally flawed",
        line_hint = "if !name.contains(\"DROP\") && !name.contains(\"DELETE\") {",
        explanation = """
Blocklists cannot enumerate all dangerous patterns:
- Case variations: drop, DrOp, DROP
- Encoding: %44%52%4F%50 (URL encoded)
- Comments: DR/*comment*/OP
- Alternative syntax: TRUNCATE, INSERT, UPDATE
- Unicode confusion attacks

Always use allowlisting or parameterized queries.
"""
    },
    {
        severity = "high",
        category = "Authorization/Access Control",
        description = "No authorization check - any user can access any data",
        line_hint = "async fn get_user(pool: &DbPool, input: GetUserInput)",
        explanation = """
There's no check that the caller is authorized to:
- Search for any user
- View any user's data
- Update any user's nickname

In a production system, you'd validate:
- Authenticated user identity
- Permission to access requested data
- Rate limiting per user
"""
    },
    {
        severity = "medium",
        category = "Data Exposure",
        description = "Returns all columns including potentially sensitive 'role'",
        line_hint = "SELECT id, name, email, role FROM users",
        explanation = """
The 'role' column might contain sensitive information about user privileges.
Consider:
- Filtering columns based on caller's permissions
- Not exposing internal role values
- Using a separate admin tool for role information
"""
    },
    {
        severity = "medium",
        category = "Defense in Depth",
        description = "No LIMIT clause - potential DoS via large result sets",
        line_hint = "SELECT id, name, email, role FROM users WHERE 1=1",
        explanation = """
Without LIMIT, an attacker could:
- Request all users (memory exhaustion)
- Slow down the database
- Block other queries

Always add a reasonable LIMIT and paginate results.
"""
    },
    {
        severity = "low",
        category = "Defense in Depth",
        description = "Using writable database connection for 'read-only' operations",
        line_hint = ".connect(\"sqlite:users.db\")",
        explanation = """
For defense in depth, read-only operations should use:
- A read-only database user
- A read-replica connection
- Connection string with read-only mode

This prevents SQL injection from causing writes even if validation fails.
"""
    },
]

[exercise.ai_instructions]
role = """
You are mentoring a student in security-focused code review. This is their
first exposure to SQL injection vulnerabilities. Guide them to understand
both the vulnerability and the secure alternative.
"""

approach = """
1. START WITH CONTEXT:
   - Ask if they're familiar with SQL injection
   - If not, explain the basic concept with a simple example
   - "Imagine you search for: Bob' OR '1'='1"

2. SYSTEMATIC REVIEW:
   - Go function by function
   - For each, ask: "How is user input used in the query?"
   - When they find string concatenation: "What could an attacker put there?"

3. DEMONSTRATE ATTACKS:
   - For each vulnerability, help them construct a proof-of-concept
   - "If name was `'; DROP TABLE users; --`, what would the query be?"
   - Walk through the resulting SQL step by step

4. TEACH THE FIX:
   - Introduce parameterized queries
   - Show the sqlx bind syntax:
     ```rust
     sqlx::query("SELECT * FROM users WHERE name LIKE ?")
         .bind(format!("%{}%", name))
         .fetch_all(&pool)
         .await
     ```
   - Explain WHY it's safe (SQL structure vs data)

5. DISCUSS DEFENSE IN DEPTH:
   - Even with parameterized queries, what else should be done?
   - Allowlisting for column names (can't parameterize ORDER BY)
   - Read-only database connections
   - Principle of least privilege

6. BLOCKLIST DISCUSSION:
   - Why did the blocklist fail?
   - Can you ever enumerate all dangerous patterns?
   - What's the fundamental difference from allowlisting?
"""

common_patterns = """
Issues students often miss:
- ORDER BY injection (not in a string literal, so often overlooked)
- The update_nickname contradicting "read-only" claim
- user_id being String type allowing injection

Issues students often find first:
- The obvious name filter with format!()
- The blocklist being easily bypassed
- Missing LIMIT clause

Students might ask:
- "Is it safe if I just escape quotes?" - No, explain double encoding
- "What about an ORM?" - Explain ORMs can have injection if misused
- "How would a real attack work?" - Walk through a UNION-based attack
"""

[exercise.secure_alternative]
description = "Here's how the code should look with parameterized queries:"
code = """
async fn search_users(pool: &DbPool, input: SearchUsersInput) -> anyhow::Result<Vec<User>> {
    let mut conditions = vec!["1=1".to_string()];
    let mut params: Vec<String> = vec![];

    if let Some(name) = &input.name {
        conditions.push("name LIKE ?".to_string());
        params.push(format!("%{}%", name));
    }

    if let Some(domain) = &input.email_domain {
        conditions.push("email LIKE ?".to_string());
        params.push(format!("%@{}", domain));
    }

    // For ORDER BY, use an allowlist - can't parameterize column names
    let allowed_columns = ["id", "name", "email"];
    let order_clause = match &input.sort_by {
        Some(col) if allowed_columns.contains(&col.as_str()) => {
            let direction = match &input.sort_order {
                Some(o) if o.to_lowercase() == "desc" => "DESC",
                _ => "ASC",
            };
            format!(" ORDER BY {} {}", col, direction)
        }
        _ => String::new(),
    };

    let query = format!(
        "SELECT id, name, email, role FROM users WHERE {} LIMIT 100{}",
        conditions.join(" AND "),
        order_clause
    );

    // Build query with dynamic binding
    let mut query_builder = sqlx::query_as::<_, (i64, String, String, String)>(&query);
    for param in &params {
        query_builder = query_builder.bind(param);
    }

    let rows = query_builder.fetch_all(pool.as_ref()).await?;

    Ok(rows.into_iter().map(|(id, name, email, role)| {
        User { id, name, email, role }
    }).collect())
}
"""

[exercise.reflection]
questions = [
    "Why can't you parameterize ORDER BY column names?",
    "What's the difference between escaping quotes and parameterized queries?",
    "If the database user only has SELECT permission, is SQL injection still dangerous?",
    "How would you test for SQL injection in an automated way?",
]

expected_insights = [
    "SQL grammar requires column names as identifiers, not string values; use allowlisting instead",
    "Escaping can be bypassed (encoding, double encoding); parameterization separates SQL structure from data",
    "Yes - can still read sensitive data (passwords, API keys), cause DoS, access unauthorized rows",
    "Fuzzing with SQL payloads, static analysis tools like SQLCheck, manual testing with quotes and UNION",
]
