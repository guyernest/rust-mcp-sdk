# Multi-Target Deployment Architecture

**Status**: Design Approved
**Date**: 2025-11-21
**Version**: 1.0

---

## Core Principle: Separation of Concerns

MCP server business logic (tools, resources, prompts) should be **100% generic and portable**. Target-specific code (AWS Lambda bootstrap, Cloudflare Workers, Docker, etc.) should be **scaffolding added by cargo-pmcp**.

## Architecture Pattern: Scaffold + Adapter

### High-Level Design

```
User's MCP Server (Generic)
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs          # Generic server: pub fn create_server() -> McpServer
â”‚   â””â”€â”€ main.rs         # Stdio for local dev (optional)
â”‚
â”œâ”€â”€ deploy/             # Generated by cargo-pmcp (DO NOT EDIT MANUALLY)
â”‚   â”œâ”€â”€ cloudflare/
â”‚   â”‚   â”œâ”€â”€ Cargo.toml  # Dependencies: worker, pmcp
â”‚   â”‚   â”œâ”€â”€ src/lib.rs  # Generated adapter
â”‚   â”‚   â””â”€â”€ wrangler.toml
â”‚   â”‚
â”‚   â”œâ”€â”€ lambda/
â”‚   â”‚   â”œâ”€â”€ Cargo.toml  # Dependencies: lambda_runtime, pmcp
â”‚   â”‚   â”œâ”€â”€ src/main.rs # Generated bootstrap
â”‚   â”‚   â””â”€â”€ template.yaml
â”‚   â”‚
â”‚   â””â”€â”€ docker/
â”‚       â”œâ”€â”€ Dockerfile
â”‚       â””â”€â”€ docker-compose.yml
â”‚
â””â”€â”€ .pmcp/
    â””â”€â”€ deploy.toml     # Tracks all initialized targets
```

---

## User's Generic Server

### Required Structure

Users must expose a **factory function** that creates their MCP server:

```rust
// src/lib.rs - Stays 100% generic
use pmcp::prelude::*;

pub fn create_server() -> McpServer {
    McpServer::builder()
        .name("calculator")
        .version("1.0.0")
        .tool("add", add_tool)
        .tool("subtract", subtract_tool)
        .resource("data", data_resource)
        .prompt("help", help_prompt)
        .build()
}

// Tool implementations (generic)
fn add_tool(args: Value) -> Result<Value> {
    let a = args["a"].as_f64().unwrap();
    let b = args["b"].as_f64().unwrap();
    Ok(json!({ "result": a + b }))
}
```

### Optional: Stdio for Local Development

```rust
// src/main.rs - For local development/testing
fn main() {
    let server = create_server();
    pmcp::stdio::run(server);
}
```

### Key Characteristics
- âœ… No target-specific dependencies in main `Cargo.toml`
- âœ… No `#[event(fetch)]`, `#[tokio::main]`, or other runtime macros
- âœ… Pure business logic - tools, resources, prompts
- âœ… Easy to test (just call `create_server()`)
- âœ… Works with cross-cutting concerns (observability, auth, middleware)

---

## Cargo PMCP Scaffolding

### Initialize Deployment Target

```bash
# Initialize Cloudflare Workers deployment
cargo pmcp deploy init --target cloudflare-workers

# Initialize AWS Lambda deployment
cargo pmcp deploy init --target aws-lambda

# Initialize Docker deployment
cargo pmcp deploy init --target docker

# Initialize multiple targets
cargo pmcp deploy init --target cloudflare-workers
cargo pmcp deploy init --target aws-lambda
# Now deploy/ has both cloudflare/ and lambda/
```

### What `init` Does

1. **Detects user's crate structure**
   - Finds the crate with `pub fn create_server()`
   - Or suggests creating this function if not found

2. **Creates target directory**
   - `deploy/<target>/` with complete project structure

3. **Generates Cargo.toml**
   - Target-specific dependencies (`worker`, `lambda_runtime`, etc.)
   - Imports parent crate as dependency

4. **Generates adapter code**
   - `src/lib.rs` or `src/main.rs` depending on target
   - Calls `create_server()` from parent crate
   - Uses `pmcp::adapters::<target>` for target-specific logic

5. **Generates target configuration**
   - `wrangler.toml` for Cloudflare
   - `template.yaml` for AWS Lambda
   - `Dockerfile` for Docker

6. **Updates `.pmcp/deploy.toml`**
   - Tracks all initialized targets
   - Stores target-specific configuration

---

## Generated Adapter Code

### Cloudflare Workers Adapter

```rust
// deploy/cloudflare/src/lib.rs
// GENERATED BY cargo-pmcp - DO NOT EDIT MANUALLY
// Regenerate with: cargo pmcp deploy init --target cloudflare-workers --regenerate

use calculator::create_server;  // From parent crate
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    console_error_panic_hook::set_once();

    // User's generic server
    let server = create_server();

    // PMCP-provided adapter handles Cloudflare-specific details
    pmcp::adapters::cloudflare::serve(server, req, env, ctx).await
}
```

### AWS Lambda Adapter

```rust
// deploy/lambda/src/main.rs
// GENERATED BY cargo-pmcp - DO NOT EDIT MANUALLY
// Regenerate with: cargo pmcp deploy init --target aws-lambda --regenerate

use calculator::create_server;
use lambda_runtime::{service_fn, Error, LambdaEvent};
use lambda_http::{Request, Response};

#[tokio::main]
async fn main() -> Result<(), Error> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .with_target(false)
        .without_time()
        .init();

    let server = create_server();

    // PMCP-provided adapter handles Lambda specifics
    let handler = pmcp::adapters::lambda::handler(server);
    lambda_runtime::run(service_fn(handler)).await
}
```

### Docker Adapter

```rust
// deploy/docker/src/main.rs
// GENERATED BY cargo-pmcp - DO NOT EDIT MANUALLY

use calculator::create_server;
use std::net::SocketAddr;

#[tokio::main]
async fn main() {
    let server = create_server();

    let addr = SocketAddr::from(([0, 0, 0, 0], 8080));

    // PMCP-provided adapter handles HTTP server
    pmcp::adapters::http::serve(server, addr).await
        .expect("Failed to start HTTP server");
}
```

---

## PMCP Adapters Library

The `pmcp` crate provides reusable adapters for each deployment target:

```rust
// In pmcp crate: src/adapters/mod.rs
pub mod cloudflare;
pub mod lambda;
pub mod http;
pub mod spin;

// src/adapters/cloudflare.rs
use crate::McpServer;
use worker::{Request, Response, Env, Context, Result};

/// Adapter for Cloudflare Workers
/// Handles CORS, JSON-RPC parsing, routing, and response formatting
pub async fn serve(
    server: McpServer,
    req: Request,
    env: Env,
    ctx: Context
) -> Result<Response> {
    // Handle CORS preflight
    if req.method() == worker::Method::Options {
        return cors_preflight();
    }

    // Handle GET requests with server info
    if req.method() == worker::Method::Get {
        return server_info(&server);
    }

    // Parse JSON-RPC request
    let body = req.text().await?;
    let request: JsonRpcRequest = serde_json::from_str(&body)?;

    // Route to server
    let response = server.handle_request(request).await;

    // Format response with proper headers
    Ok(json_response(response))
}

// src/adapters/lambda.rs
/// Adapter for AWS Lambda with API Gateway
pub fn handler(server: McpServer) -> impl Fn(LambdaEvent<ApiGatewayRequest>) -> ... {
    move |event| {
        // Parse API Gateway event
        // Route to server.handle_request()
        // Format API Gateway response
    }
}

// src/adapters/http.rs
/// Adapter for generic HTTP servers (Docker, Fermyon Spin, etc.)
pub async fn serve(server: McpServer, addr: SocketAddr) {
    // Create HTTP server (axum, hyper, etc.)
    // Handle MCP over HTTP
}
```

---

## Deployment Workflow

### One-Time Setup

```bash
# 1. Initialize deployment target
cargo pmcp deploy init --target cloudflare-workers

# 2. Authenticate with provider (if needed)
wrangler login

# 3. Deploy
cargo pmcp deploy --target cloudflare-workers
```

### Regular Deployment

```bash
# Deploy to specific target
cargo pmcp deploy --target cloudflare-workers

# Deploy to all configured targets
cargo pmcp deploy --all

# View deployment info
cargo pmcp deploy outputs --target cloudflare-workers

# View logs
cargo pmcp deploy logs --tail --target cloudflare-workers
```

### Multi-Target Deployment

```bash
# Initialize multiple targets
cargo pmcp deploy init --target cloudflare-workers
cargo pmcp deploy init --target aws-lambda
cargo pmcp deploy init --target docker

# Deploy to all targets
cargo pmcp deploy --all

# Or deploy individually
cargo pmcp deploy --target cloudflare-workers
cargo pmcp deploy --target aws-lambda
cargo pmcp deploy --target docker
```

---

## Cross-Cutting Concerns

### Observability (Future)

```rust
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", add_tool)
        .with_observability(OpenTelemetry::new())  // Works on all targets
        .build()
}
```

### Authentication (Future)

```rust
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", add_tool)
        .with_auth(OAuth::new("https://auth.example.com"))  // Works on all targets
        .build()
}
```

### Custom Middleware (Future)

```rust
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", add_tool)
        .layer(CustomMiddleware::new())  // Tower-style middleware
        .layer(RateLimiter::new(100))
        .layer(Cache::new())
        .build()
}
```

---

## Benefits

### 1. Generic Server Code âœ…
- No target-specific code in user's server
- Same code works everywhere
- Easy to test and maintain
- Simple mental model

### 2. Easy Multi-Target Deployment âœ…
```bash
cargo pmcp deploy --target cloudflare-workers
cargo pmcp deploy --target aws-lambda
cargo pmcp deploy --target docker
```

### 3. Managed Scaffolding âœ…
- Cargo PMCP generates and manages adapter code
- Users never touch target-specific boilerplate
- Can regenerate adapters as targets evolve
- Clear separation: `src/` (user) vs `deploy/` (generated)

### 4. Progressive Enhancement âœ…
```rust
// Start simple
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", add_tool)
        .build()
}

// Add complexity as needed
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", add_tool)
        .with_observability(OpenTelemetry::new())
        .with_auth(OAuth::new(...))
        .layer(RateLimiter::new(100))
        .build()
}
```

### 5. Community Extensibility âœ…
- New targets can be added as plugins
- Adapter pattern is well-documented
- Community can contribute new adapters
- PMCP maintains core adapters

---

## Implementation Phases

### Phase 1: Scaffolding (Current Sprint) ðŸš§
**Goal**: Improve `cargo pmcp deploy init` to scaffold proper adapter projects

**Tasks**:
- [x] Design architecture
- [ ] Detect `pub fn create_server()` in user's crate
- [ ] Generate `deploy/<target>/` directory structure
- [ ] Generate Cargo.toml with correct dependencies
- [ ] Generate adapter code (src/lib.rs or src/main.rs)
- [ ] Generate target configuration files
- [ ] Update `.pmcp/deploy.toml` to track targets
- [ ] Implement for Cloudflare Workers
- [ ] Implement for AWS Lambda
- [ ] Documentation and examples

### Phase 2: Adapters Library (Next Sprint)
**Goal**: Add `pmcp::adapters::*` modules for reusable adapter code

**Tasks**:
- [ ] Design adapter API
- [ ] Implement `pmcp::adapters::cloudflare`
- [ ] Implement `pmcp::adapters::lambda`
- [ ] Implement `pmcp::adapters::http`
- [ ] Implement `pmcp::adapters::spin`
- [ ] Simplify generated code to just call adapters
- [ ] Documentation for adapter API
- [ ] Community contribution guidelines

### Phase 3: Cross-Cutting Concerns (Future)
**Goal**: Add middleware pattern for observability, auth, etc.

**Tasks**:
- [ ] Design middleware/layer API (Tower-inspired)
- [ ] Implement `.with_observability()` builder method
- [ ] Implement `.with_auth()` builder method
- [ ] Implement `.layer()` for custom middleware
- [ ] OpenTelemetry integration
- [ ] OAuth/JWT authentication
- [ ] Rate limiting
- [ ] Caching
- [ ] Documentation and examples

---

## Acceptable Complexity in Generic Server

### âœ… Acceptable in Generic Server
- `lib.rs` + `main.rs` structure (lib for targets, main for stdio)
- Middleware/layer pattern for cross-cutting concerns
- Builder pattern with `.with_observability()`, `.with_auth()`
- Feature flags for optional dependencies (`features = ["observability", "auth"]`)
- Generic `pub fn create_server() -> McpServer` factory

### âŒ Should Stay in Adapters
- `#[event(fetch)]`, `#[tokio::main]`, runtime-specific macros
- Target-specific HTTP types (`worker::Request`, `lambda_http::Request`)
- Target-specific runtime setup and configuration
- Deployment-specific error handling
- Target-specific dependency injection

---

## Comparison to Alternatives

### Alternative 1: Monolithic (Current wasm-mcp-server)
```rust
// âŒ Target-specific code in main server
#[event(fetch)]  // Cloudflare-specific
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    let server = WasmMcpServer::builder()
        .tool("calculator", ...)
        .build();
    // Cloudflare-specific HTTP handling
}
```

**Problems**:
- Can't deploy to other targets
- Hard to test (requires Cloudflare runtime)
- Tightly coupled to deployment target

### Alternative 2: Feature Flags
```rust
#[cfg(feature = "cloudflare")]
#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> { ... }

#[cfg(feature = "lambda")]
#[tokio::main]
async fn main() -> Result<(), Error> { ... }
```

**Problems**:
- Still pollutes user's code with target-specific logic
- Hard to maintain multiple entrypoints
- Feature explosion (cloudflare, lambda, docker, spin, etc.)
- User must understand all targets

### Our Approach: Scaffold + Adapter âœ…
```rust
// User's src/lib.rs - 100% generic
pub fn create_server() -> McpServer {
    McpServer::builder()
        .tool("calculator", ...)
        .build()
}

// deploy/cloudflare/src/lib.rs - Generated by cargo-pmcp
use my_server::create_server;
#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    pmcp::adapters::cloudflare::serve(create_server(), req, env, ctx).await
}
```

**Benefits**:
- User's server stays generic
- Cargo PMCP manages complexity
- Easy to add new targets
- Clear separation of concerns

---

## Migration Guide

### Migrating Existing Servers

**Before** (Monolithic):
```rust
// src/lib.rs
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    let server = WasmMcpServer::builder()
        .tool("calculator", calculator_tool)
        .build();
    // Handle request...
}
```

**After** (Generic):
```rust
// src/lib.rs
use pmcp::prelude::*;

pub fn create_server() -> McpServer {
    McpServer::builder()
        .name("calculator")
        .tool("calculator", calculator_tool)
        .build()
}

// Then run:
// cargo pmcp deploy init --target cloudflare-workers
// This generates deploy/cloudflare/ with proper adapter
```

---

## Reference Implementation

See `examples/wasm-mcp-server/` for the current monolithic approach.

See `examples/generic-mcp-server/` (coming soon) for the new scaffold + adapter approach.

---

## Questions & Answers

**Q: Do I need both `lib.rs` and `main.rs`?**
A: Only `lib.rs` with `pub fn create_server()` is required. `main.rs` is optional for local stdio testing.

**Q: Can I customize the generated adapter code?**
A: No, adapter code is managed by cargo-pmcp. If you need customization, use middleware/layers instead. Adapters can be regenerated with `--regenerate` flag.

**Q: How do I test my server locally?**
A: Run `cargo run` (if you have `main.rs` with stdio) or write unit tests that call `create_server()`.

**Q: Can I deploy to multiple targets simultaneously?**
A: Yes! Initialize each target with `deploy init`, then use `deploy --all` to deploy everywhere.

**Q: What if my server needs target-specific configuration?**
A: Use environment variables or feature flags in your `create_server()` function. The server stays generic, but can adapt behavior at runtime.

**Q: How do I add a new deployment target?**
A: Implement a new target in cargo-pmcp following the adapter pattern. See `CONTRIBUTING.md` for guidelines.

---

**Last Updated**: 2025-11-21
**Status**: Design Approved, Implementation In Progress
**Next Review**: After Phase 1 completion
