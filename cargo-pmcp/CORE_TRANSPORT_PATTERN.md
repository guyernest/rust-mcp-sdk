# Core/Transport Pattern for Multi-Target Deployment

**Date**: 2025-11-21
**Status**: Design & Implementation
**Supersedes**: Parts of DEPLOYMENT_ARCHITECTURE.md

---

## Problem Statement

MCP servers with transport dependencies (tokio networking, axum, lambda_runtime) cannot compile to WASM because:
- `streamable-http` feature pulls in tokio with net features
- Tokio networking depends on `mio`
- `mio` explicitly doesn't support WASM targets

## Solution: Core/Transport Split

Separate MCP server business logic (tools, resources, prompts) from transport layer (HTTP, Lambda, stdio, WASM).

---

## Architecture

### Project Structure

```
my-mcp-project/
├── crates/
│   ├── mcp-myapp-core/        # ✅ WASM-compatible business logic
│   │   ├── Cargo.toml         # Minimal deps: pmcp (no transport features)
│   │   └── src/
│   │       └── lib.rs         # pub fn build_server() -> Server
│   │
│   ├── myapp-server/          # Stdio transport (optional)
│   │   ├── Cargo.toml         # Uses mcp-myapp-core + tokio
│   │   └── src/
│   │       └── main.rs        # Stdio runner for local dev
│   │
│   └── server-common/         # Shared transport utilities (optional)
│       └── src/
│           └── lib.rs         # HTTP adapters, middleware, etc.
│
├── deploy/                    # Generated by cargo-pmcp
│   ├── cloudflare/
│   │   ├── Cargo.toml         # Uses mcp-myapp-core (WASM-compatible!)
│   │   └── src/lib.rs         # Cloudflare adapter
│   │
│   └── lambda/
│       ├── Cargo.toml         # Uses mcp-myapp-core + lambda_runtime
│       └── src/main.rs        # Lambda bootstrap
│
└── Cargo.toml                 # Workspace root
```

---

## Core Package Requirements

### Minimal Dependencies

The core package should ONLY depend on:
- `pmcp` with minimal features (NO `streamable-http`, NO transport features)
- Business logic dependencies (serde, validation, etc.)
- `tokio` ONLY in `[dev-dependencies]` for tests

```toml
# crates/mcp-myapp-core/Cargo.toml
[package]
name = "mcp-myapp-core"
version = "0.1.0"
edition = "2021"

[dependencies]
pmcp = { workspace = true, default-features = false, features = ["schema-generation", "validation"] }
serde = { workspace = true }
serde_json = { workspace = true }
schemars = { workspace = true }
anyhow = { workspace = true }
thiserror = { workspace = true }
validator = { workspace = true }

[dev-dependencies]
tokio = { workspace = true }  # Only for tests
```

### Core Package API

```rust
// crates/mcp-myapp-core/src/lib.rs

use pmcp::{Server, TypedTool};
use pmcp::types::capabilities::ServerCapabilities;

/// Build the MCP server with all business logic
///
/// This function is 100% transport-agnostic and WASM-compatible.
/// It can be used by any transport adapter (Cloudflare, Lambda, stdio, etc.)
pub fn build_server() -> pmcp::Result<Server> {
    Server::builder()
        .name("myapp")
        .version("1.0.0")
        .capabilities(ServerCapabilities::tools_only())
        .tool("my_tool", TypedTool::new("my_tool", |input, _extra| {
            Box::pin(async move {
                // Business logic here
                Ok(serde_json::json!({"result": "success"}))
            })
        }))
        .build()
}
```

**Key Characteristics:**
- ✅ No `#[tokio::main]`, `#[event(fetch)]`, or runtime macros
- ✅ No tokio in main dependencies (only dev-dependencies)
- ✅ No HTTP types (axum, hyper, etc.)
- ✅ Pure business logic
- ✅ WASM-compatible
- ✅ Easy to test

---

## Transport Packages

### Stdio Transport (for local development)

```rust
// crates/myapp-server/src/main.rs
use mcp_myapp_core::build_server;

fn main() {
    let server = build_server().expect("Failed to build server");
    pmcp::stdio::run(server);
}
```

```toml
# crates/myapp-server/Cargo.toml
[dependencies]
mcp-myapp-core = { path = "../mcp-myapp-core" }
pmcp = { workspace = true }  # Can use full features
tokio = { workspace = true }
```

### Lambda Transport (generated by cargo-pmcp)

```rust
// deploy/lambda/src/main.rs
use mcp_myapp_core::build_server;

#[tokio::main]
async fn main() -> Result<(), lambda_runtime::Error> {
    let server = build_server()?;
    // Lambda-specific bootstrap
    pmcp::adapters::lambda::serve(server).await
}
```

### Cloudflare Workers Transport (generated by cargo-pmcp)

```rust
// deploy/cloudflare/src/lib.rs
use mcp_myapp_core::build_server;
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    let server = build_server().map_err(|e| worker::Error::RustError(e.to_string()))?;
    pmcp::adapters::cloudflare::serve(server, req, env, ctx).await
}
```

---

## Cargo PMCP Integration

### Auto-Detection Strategy

When running `cargo pmcp deploy init --target <target>`, the tool should:

1. **Search for core package** (priority order):
   - Look for packages with `-core` suffix: `mcp-*-core`, `*-core`
   - Parse Cargo.toml to verify it has `pmcp` dependency
   - Check that it has minimal transport dependencies
   - Verify it exports a `build_server()` or `create_server()` function

2. **Fallback to any package** if no `-core` package found:
   - Search for any package with `pub fn build_server()` or `create_server()`
   - Warn user if package has transport dependencies that might not work with target

3. **Suggest creating core package** if none found:
   ```
   ⚠️  No core package found!

   For multi-target deployment, we recommend splitting your server:
   1. Core package (business logic) - WASM-compatible
   2. Transport packages (stdio, HTTP, etc.) - Use the core

   Run: cargo pmcp init core --name myapp
   This will create: crates/mcp-myapp-core/
   ```

### Updated Init Process

```rust
// Simplified flow
async fn init_cloudflare(config: &DeployConfig) -> Result<()> {
    // 1. Find core package (not transport package!)
    let (core_package, core_path) = find_core_package(&config.project_root)?;

    // 2. Verify it's WASM-compatible
    verify_wasm_compatible(&core_path)?;

    // 3. Generate adapter that imports core package
    create_cloudflare_adapter(&deploy_dir, &core_package, &core_path)?;
}
```

---

## Benefits

### 1. WASM Compatibility ✅
Core package has no mio/tokio networking, compiles to WASM without issues.

### 2. Clean Separation ✅
- **Core**: Business logic, tools, resources, prompts
- **Transport**: HTTP servers, Lambda runtimes, Workers adapters

### 3. Easy Testing ✅
```rust
#[tokio::test]
async fn test_server_builds() {
    let server = build_server();
    assert!(server.is_ok());
}
```

### 4. Multi-Target Deployment ✅
Same core package used by all deployment targets:
- Cloudflare Workers (WASM)
- AWS Lambda (x86_64/aarch64)
- Docker (x86_64/aarch64)
- Stdio (local development)

### 5. Progressive Complexity ✅
Start simple with just core package, add transport packages as needed.

---

## Migration Guide

### From Monolithic Server

**Before** (monolithic):
```rust
// src/lib.rs - Mixed business logic + transport
use worker::*;

#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    let server = WasmMcpServer::builder()
        .tool("calculator", calculator_tool)
        .build();
    // Handle Cloudflare-specific logic...
}
```

**After** (core/transport split):
```rust
// crates/mcp-myapp-core/src/lib.rs - Pure business logic
pub fn build_server() -> pmcp::Result<Server> {
    Server::builder()
        .tool("calculator", calculator_tool)
        .build()
}

// deploy/cloudflare/src/lib.rs - Generated by cargo-pmcp
use mcp_myapp_core::build_server;
#[event(fetch)]
async fn main(req: Request, env: Env, ctx: Context) -> Result<Response> {
    pmcp::adapters::cloudflare::serve(build_server()?, req, env, ctx).await
}
```

### From Lambda-Specific Server

**Before**:
```rust
// src/main.rs - Lambda-specific
#[tokio::main]
async fn main() -> Result<(), lambda_runtime::Error> {
    let server = McpServer::builder()
        .tool("calculator", calculator_tool)
        .build()?;
    // Lambda-specific bootstrap...
}
```

**After**:
```rust
// crates/mcp-myapp-core/src/lib.rs
pub fn build_server() -> pmcp::Result<Server> {
    Server::builder()
        .tool("calculator", calculator_tool)
        .build()
}

// deploy/lambda/src/main.rs - Generated by cargo-pmcp
use mcp_myapp_core::build_server;
#[tokio::main]
async fn main() -> Result<(), lambda_runtime::Error> {
    pmcp::adapters::lambda::serve(build_server()?).await
}

// Now also works with Cloudflare!
// cargo pmcp deploy init --target cloudflare-workers
```

---

## Implementation Checklist

- [x] Document core/transport pattern
- [ ] Update `find_server_package()` to prioritize `-core` packages
- [ ] Add WASM compatibility check
- [ ] Update Cloudflare adapter generation to use core package
- [ ] Update Lambda adapter generation to use core package
- [ ] Add `cargo pmcp init core` command
- [ ] Update documentation examples
- [ ] Add migration guide

---

## Example: Calculator Core Package

```rust
// crates/mcp-calculator-core/src/lib.rs

use pmcp::{Server, TypedTool};
use pmcp::types::capabilities::ServerCapabilities;
use serde::{Deserialize, Serialize};
use schemars::JsonSchema;
use validator::Validate;

#[derive(Debug, Serialize, Deserialize, JsonSchema, Validate)]
pub struct AddInput {
    #[validate(range(min = -1000000.0, max = 1000000.0))]
    pub a: f64,
    #[validate(range(min = -1000000.0, max = 1000000.0))]
    pub b: f64,
}

pub fn build_calculator_server() -> pmcp::Result<Server> {
    Server::builder()
        .name("calculator")
        .version("1.0.0")
        .capabilities(ServerCapabilities::tools_only())
        .tool(
            "add",
            TypedTool::new("add", |input: AddInput, _extra| {
                Box::pin(async move {
                    input.validate()
                        .map_err(|e| pmcp::Error::validation(format!("{}", e)))?;

                    let result = input.a + input.b;
                    Ok(serde_json::json!({
                        "result": result,
                        "operation": format!("{} + {} = {}", input.a, input.b, result)
                    }))
                })
            })
            .with_description("Add two numbers together"),
        )
        .build()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_server_builds() {
        let server = build_calculator_server();
        assert!(server.is_ok());
    }
}
```

```toml
# crates/mcp-calculator-core/Cargo.toml
[package]
name = "mcp-calculator-core"
version = "0.1.0"
edition = "2021"

[dependencies]
pmcp = { workspace = true, default-features = false, features = ["schema-generation", "validation"] }
serde = { workspace = true }
serde_json = { workspace = true }
schemars = { workspace = true }
validator = { workspace = true }
anyhow = { workspace = true }
thiserror = { workspace = true }

[dev-dependencies]
tokio = { workspace = true }
```

---

## Conclusion

The core/transport split pattern:
- ✅ Enables WASM compilation (no mio/tokio networking in core)
- ✅ Maintains clean separation of concerns
- ✅ Supports all deployment targets from single codebase
- ✅ Is already used in the test calculator project
- ✅ Just needs cargo-pmcp to detect and use core packages

**Next Step**: Update cargo-pmcp's Cloudflare init to detect and use `-core` packages instead of transport packages.
